---
title: "README - Wrangling Cannabis Data Sets"
author: "Martin Frigaard"
date: "current version: `r Sys.Date()`"
output: github_document
---


```{r setup, include=FALSE}
library(knitr)
library(rmdformats)
require(tidyverse)
library(plotly)
require(janitor)
require(skimr)
library(mosaic)
library(inspectdf)
library(visdat)
library(DT)
library(hrbrthemes)
# base options ----
base::options(
  tibble.print_max = 25,
  tibble.width = 78,
  scipen = 100000000,
  max.print = 999999
)
# knitr chunk options ----
knitr::opts_chunk$set(
  echo = FALSE, # show/hide all code
  # results = "hide", # hide results
  tidy = FALSE, # cleaner code printing
  comment = "#> ", # better console printing
  eval = TRUE, # turn this to FALSE stop code chunks from running
  message = TRUE, # show messages
  fig.width = 9, # figure width
  fig.height = 6, # figure height
  warning = FALSE, # show warnings
  size = "small", # size of the text
  fig.path = "figs/"
) # location of files
# knitr knit settings ----
knitr::opts_knit$set(
  width = 78
)
```

# Motivation

This script outlines the steps to wrangle the Cannabis data. We used an open online retail data set from the [UCI Machine Learning Laboratory](https://archive.ics.uci.edu/ml/datasets/online+retail) for the week-over-week visualizations (`OnlineRetail`), and combined this with categories from the [`kushyapp`](https://github.com/kushyapp/cannabis-dataset).

## Import the data 

All of the data are in the `data/` folder. 

```{r data-folder, message=FALSE, warning=FALSE}
fs::dir_tree("data/", recurse = FALSE)
```

### The Online Retail Data

The folder tree for the `data/online-retail` folder is below. 

```{r data-files, message=FALSE, warning=FALSE}
fs::dir_tree("data/online-retail", recurse = FALSE)
```

We will import these in the next code block. 

```{r OnlineRetail}
OnlineRetail <- readr::read_csv("data/online-retail/Online_Retail.csv") %>% 
  janitor::clean_names(case = "snake")
OnlineRetail %>% dplyr::glimpse()
```

This is huge, so we will take a 10% sample. 

```{r SmOnlineRetail}
SmOnlineRetail <- dplyr::sample_frac(tbl = OnlineRetail, size = 1/10)
SmOnlineRetail %>% dplyr::glimpse(78)
```

This is much easier to deal with.

### Wrangle the retail variables

The goal here is to simulate some cannabis data by combining the `SmOnlineRetail` data set with the kushy data sets. The best place to make the join is in the `description` or `stock_code`. First we will wrangle the variables and then we can see what the best option is to join these two data frames together. 

```{r wrangle}
SmOnlineRetail <- SmOnlineRetail %>% 
    dplyr::mutate(
                # create invoice date
                invoice_date = as.Date(invoice_date, "%m/%d/%y"),
                # day of week
                dow = lubridate::day(invoice_date), 
                # week of the year
                week = lubridate::week(invoice_date),
                # year 
                yr = lubridate::year(invoice_date), 
                # week_year (with floor_date)
                week_year = lubridate::floor_date(invoice_date, 
                                                  unit = "week"),
                # create month
                month = lubridate::month(week_year, 
                                         abbr = TRUE, 
                                         label = TRUE),
                # floor_month
                floor_month = lubridate::floor_date(week_year, 
                                                    unit = "month"))
```

Now we can check and see what these data look like with `skimr::skim()`.

```{r skim-SmOnlineRetail}
SmOnlineRetail %>% skimr::skim()
```

This looks like all the wrangling worked in the way we wanted. Now lets check the counts on some of the categories. First we will check and see how many different `invoice_no`s and `stock_code`s there are:

Below are the unique number of stock codes and invoice numbers. 

```{r unique-invoice-no-stock-code}
SmOnlineRetail$invoice_no %>% unique() %>% length()
SmOnlineRetail$stock_code %>% unique() %>% length()
```

There are far more invoice numbers than stock codes, so these are a better bet for getting them to match up with the brands. 

I will group these by the invoice number and get the total cost of the sale by multiplying the unit price by the number of units sold (quantity).

### Create a 'amount-per-invoice' data set

This will group the data by the invoice number and calculate the cost per invoice (`amnt_per_invoice`) by multiplying quantity and unit price. 

```{r AmntPerInvoice}
AmntPerInvoice <- SmOnlineRetail %>% 
  group_by(invoice_no) %>% 
  dplyr::mutate(amnt_per_invoice = quantity*unit_price) %>% 
  dplyr::ungroup() %>% 
  dplyr::select(invoice_no, 
                invoice_date,
                quantity, 
                unit_price, 
                amnt_per_invoice,
                dplyr::everything(),
                -c(country))
AmntPerInvoice %>% head(10)
```

We can check the calculations by taking a quick case (invoice `548920`). 

```{r test-amnt_per_invoice}
# quantity * unit_price
5*2.95
```


Now I have a data set with the cost of each invoice, and I can use this join the Kushy brand data. 

## Import the Kushy data 

These data sets provide the categories and brands from the Cannabis industry. 

```{r kushy_files}
kushy_files <- fs::dir_ls("data/kushy-datasets/csv", regexp = "kushy_")
writeLines(kushy_files)
```

Import these files.

```{r import-kushy-data, message=FALSE, warning=FALSE}
KushyBrands <- readr::read_csv(kushy_files[1])
KushyProducts <- readr::read_csv(kushy_files[2])
KushyShops <- readr::read_csv(kushy_files[3])
KushyStrains <- readr::read_csv(kushy_files[4])
```

## Kushy Brands

These are the categories in the `KushyBrands` data frame. I want to see how many unique brands are represented here, but first I need to know what I am dealing with in terms of completeness. I can check this with `skimr`

```{r KushyBrands-skim}
KushyBrands %>% skimr::skim()
```

This shows I can remove the `instagram` variable, and the `category` variable is missing `406` values. Hopefully this won't an issue. We can do without the `slug` too. 

```{r remove-slug-instagram}
KushyBrands <- KushyBrands %>% 
  # remove the instagram and slug variables
  dplyr::select(-c(instagram, slug)) %>% 
  dplyr::rename(mult_category = category)
KushyBrands %>% dplyr::glimpse(78)
```

Now I can check the unique `name`s for each brand. These are stored in the `name` variable.

### Brand names

These are the brand names in the `KushyBrands` data frame.

```{r name-unique-length}
KushyBrands %>% 
  dplyr::count(name, sort = TRUE) 
```

The output above shows us there are `1776` unique observations in the `name` variable, but two of them (`Brewbudz by Cannabiniers` and `Dixie Elixirs & Edibles`) appear more than once. If there are `1776` unique brand names, I might want to check another variable before linking to the `AmntPerInvoice` to the `KushyBrands` data frame...

### Kushy brand categories 

When we look at the categories we see that there are multiple categories (`mult_category`) crammed into a single column separated by commas. 

```{r head-KushyBrands}
KushyBrands %>% 
  utils::head(10)
```
We want to separate each category out into an individual rows, because `category` *might* be useful for itemizing products later. The categories are currently separated by commas, but we can split them up and separate the rows with `tidyr::separate_rows()`. We also need to remove the whitespace from the `category` variable, and remove any rows (with other quotes). 

```{r TidyBrandCat}
TidyBrandCat <- KushyBrands %>% 
  # split across rows
  tidyr::separate_rows(data = ., mult_category, sep = ",") %>%
  # trim the whitespace from mult_category to category
  dplyr::mutate(category = stringr::str_trim(mult_category)) %>%
  # remove the empty rows
  dplyr::filter(category != "") %>% 
  # remove the mult_category
  dplyr::select(-mult_category,
                brand_name = name)
TidyBrandCat %>% dplyr::glimpse(78)
```

We've just changed the number of rows in this data frame from `1778` to `1988` because we've added a new row for each category, and these were previously on a single row (separated by a commas). If we count the number of names now, we can see there are more counts in the `n` column.

```{r recount-names}
TidyBrandCat %>% 
  dplyr::count(brand_name, sort = TRUE) %>% 
  utils::head(10)
KushyBrands %>% 
  dplyr::count(name, sort = TRUE) %>% 
  utils::head(10)
```

These are the counts for each name (products and brands), and we can see there are fewer names in the `TidyBrandCat` data frame than the `KushyBrands` data frame. 

#### Verify the BaM case study

Check the `BaM` case study to see if there are multiple categories for this brand. 

```{r wide-BaM}
KushyBrands %>% 
  dplyr::filter(name == "BaM")
```

And we can see there are four comma-separated categories in the `KushyBrands` data, and the same four categories are in the `TidyBrandCat`. 

```{r tidy-BaM}
TidyBrandCat %>% 
  dplyr::filter(brand_name == "BaM")
```

This shows us there are five categories for `BaM` in `KushyBrands`, and five categories for `BaM` in `TidyBrandCat`. 

Now we can check the top brand categories.

## Top Brand Categories

When we check the top categories in the brands table, we see there are mostly `Concentrates`, `Flower`, and `Edibles`. 

```{r glimpse-TidyBrands}
TidyBrandCat %>% 
  dplyr::count(category, sort = TRUE) %>% 
  utils::head(10)
```

We will still want to use the `location` to replace the `country` variable in the online retail data.  

```{r count-location}
TidyBrandCat %>% 
  dplyr::count(location, sort = TRUE) %>% 
  utils::head(10)
```

We will make this a little cleaner for the graphs. 

```{r format-location}
TidyBrandCat <- TidyBrandCat %>% 
  dplyr::mutate(location = case_when(
    # alberta 
    location %in% c("AB", "ab", "Ab") ~ "Alberta",
    # manitoba
    location %in% c("MB", "mb", "Mb") ~ "Manitoba",
    # british columbia 
    location %in% c("BC", "British Columbia") ~ "British Columbia",
    # pleasant hill assuming this is Saskatchewan
    location %in% c("Pleasant Hill") ~ "Saskatchewan",
    # nova scotia
    location %in% c("NS") ~ "Nova Scotia",
    # ontario 
    location %in% c("ON") ~ "Ontario",
    # newfoundland
    location %in% c("NL") ~ "Newfoundland",
    # california 
    location %in% c("CA", "Ca", "ca", "CALIFORNIA") ~ "California",
    # colorado
    location %in% c("CO", "Colorado", "Co") ~ "Colorado",
    # washington
    location %in% c("WA", "Washington", "Wa") ~ "Washington",
     # arizona
    location %in% c("AZ", "Arizona", "Az") ~ "Arizona",
    # nevada
    location %in% c("NV", "Nv") ~ "Nevada",
    # michigan
    location %in% c("MI", "Michigan") ~ "Michigan",
    # oregon
    location %in% c("OR", "Oregon", "Or") ~ "Oregon",
    # Sp 
    location %in% c("Sp", "sp") ~ "Salisbury Postcode Area (UK)",
    # all else
    TRUE ~ location
  )) 
  
TidyBrandCat %>% dplyr::count(location, sort = TRUE)
```

Now we can see the vast majority of these are from California. We will look to join this with the product data below. 


***

## Kushy Product Data 

The kushy products are stored in the `KushyProducts` data frame. These might be a better candidate for binding to the online retail data. 

```{r KushyProducts}
KushyProducts %>% skimr::skim()
```

We will check the count of `name`s first. 

#### Product `name`

The `name` for each product is below. 

```{r name-product}
KushyProducts %>% 
  dplyr::count(name, sort = TRUE) %>% 
  utils::head(10)
```

I am going to separate these terms by the hyphen ` -` and create a `product_name` variable and `product_details` variable. These two can be used to clean up the products into categories and their names.

```{r create-new-product_name-and-product_details}
KushyProducts <- KushyProducts %>% 
  tidyr::separate(col = name, 
                  into = c("product_name", "product_details"), 
                  sep = " -",
                  remove = FALSE)
# remove the empty variables
KushyProducts <- KushyProducts %>% 
  dplyr::select(id, 
                name, 
                product_name, 
                product_details, 
                brand,
                category,
                strain,
                thc) 
KushyProducts %>% head()
```

We now have two variables, one for product name and one for product category. These each contain the same information, but arranged in different ways. 

#### Products: `category`

This is similar to the categories above.

```{r product-categories}
KushyProducts %>% 
  dplyr::count(category, sort = TRUE)
```

We need to clean the categories just like we did in the brands data frame. 

```{r clean-categories}
TidyProdCat <- KushyProducts %>% 
  # split across rows
  tidyr::separate_rows(data = ., category, sep = ",") %>%
  # trim the whitespace from mult_category to category
  dplyr::mutate(category = stringr::str_trim(category)) %>%
  # remove the empty rows
  dplyr::filter(category != "") %>% 
  # reorganize
  dplyr::select(name, 
                product_name, 
                product_details, 
                product_category = category,
                dplyr::everything()) 
TidyProdCat %>% 
  utils::head(10)
```

We can check these the same way we did with the brand categories, by selecting a case. We will use the `"Casey Jones - Crumble"` case to see if the `category` has been separated. 

```{r casey-jones}
KushyProducts %>% 
  dplyr::filter(name == "Casey Jones - Crumble")
```
This should be translated into three rows. 

```{r tidy-casey-jones}
TidyProdCat %>% 
  dplyr::filter(name == "Casey Jones - Crumble")
```

And it is!

#### Products: `id`

This looks like a unique `id` for each product in the data frame.

```{r check-ids}
identical(x = KushyProducts %>% dplyr::distinct(id) %>% base::nrow(),
          y = KushyProducts %>% base::nrow())
```

So each id is unique, and there is one per row. We know this is not the case in the new `TidyProdCat` data frame. 

#### Products: `brand`

This appears similar to the `brand` variable, but it lists many more levels. 

```{r top-ten-brands-in-products}
TidyProdCat %>% 
  dplyr::count(brand, sort = TRUE) %>% 
  utils::head(10)
```
Let's filter out the `"Unknown Producer"`s and see what these looks like. 

```{r brand-product}
TidyProdCat %>% 
  dplyr::filter(brand != "Unknown Producer") %>% 
  dplyr::count(brand, sort = TRUE) %>% 
  utils::head(10)
```

This shows there are around 1233 brands in the `TidyProdCat` data set. We'll look to bind this to the brands data set. 

## Join brands with cost per invoice

Here we're going to combine the distinct names for `product_name` with the `AmntPerInvoice` data frame. 

First I will get a data frame with only the distinct names of each product, sorted with the most common products first. 

```{r ProductCount}
ProductCount <- TidyProdCat %>%
  # remove unknown
  dplyr::filter(brand != "Unknown Producer") %>% 
  # count the product (name)
  dplyr::count(product_name, sort = TRUE) %>% 
  # join back to the original table
  dplyr::inner_join(x = ., 
                    y = TidyProdCat, 
                    by = "product_name") %>% 
  # rename n column to count
  dplyr::rename(prod_name_count = n) %>% 
  # remove the strain, name, thc, and id
  dplyr::select(-strain,
                -name,
                -thc) %>% 
  # arrange by brand count
  dplyr::arrange(desc(prod_name_count)) %>% 
  # get the distinct rows 
  dplyr::distinct(.keep_all = TRUE)
# check the dimensions
ProductCount %>% dplyr::glimpse(78)
```

This is a large data set (over 29k rows), so we can use this to sample from. We will join the `TidyBrandCat` to this table so we can keep the `location` in the data set. We can do this with a `dplyr::left_join()`, as this should keep all the original data in `ProductCount` and add the data from `TidyBrandCat`. Before joining, we should change the name of the category variable to `brand_category` to be more specific. 

```{r rename-brand_category}
TidyBrandCat <- TidyBrandCat %>% 
  dplyr::rename(brand_category = category)
```


```{r TidyProductsBrands}
TidyProductsBrands <- ProductCount %>% 
  # join the product count
  dplyr::inner_join(x = ., 
                    # to the brands
                   y = TidyBrandCat, 
                   # by the id
                   by = c("id")) %>% 
  # then organize
  dplyr::select(id, 
                location,
                dplyr::contains("prod"),
                dplyr::contains("brand")) %>% 
  dplyr::arrange(desc(prod_name_count))
TidyProductsBrands %>% dplyr::glimpse(78)
```

This might not make sense, because the ids might not be actually linked, but we will proceed as though they do. 

#### Derive sample of invoices, sorted by quantity

Now I want to get a sample from the `AmntPerInvoice` table that is the same size of the online retail data, but first make sure these are sorted by the `quantity`. I also want to add an id that matches the id's in the `TidyProductsBrands`.

Here is the kicker--I need the ids to be sorted in the *exact* same arrangement (by `prod_name_count`) because these will align with the `quantity` (i.e. most common products sync up with most sold `quantity`).

```{r AmntPerInvSamp}
AmntPerInvSamp <- AmntPerInvoice %>% 
  dplyr::sample_n(size = 2799) %>% 
  dplyr::arrange(desc(quantity)) %>% 
    # remove the description and customer_id
  dplyr::select(-description, 
                -customer_id)
AmntPerInvSamp %>% glimpse(78)
```

Now we can bind these together and reorganize the data into an arrangement that makes sense (and allows us to check our work).

```{r CannabisWowData}
CannabisWowData <- AmntPerInvSamp %>% 
  dplyr::bind_cols(TidyProductsBrands) %>% 
  dplyr::select(id, 
                location, 
                quantity, 
                unit_price, 
                amnt_per_invoice, 
                product_name, 
                prod_name_count,
                product_category,
                invoice_date,
                dow,
                week,
                yr, 
                week_year, 
                month,
                floor_month,
                dplyr::everything())
```

Export these data to processed data folder. 

```{r processed-data}
if (!file.exists("data/processed/")) {
  dir.create("data/processed/")
}
# check
fs::dir_tree("data", recurse = FALSE)
```

Time-stamp and export.

```{r export}
# export these with a time stamp
readr::write_csv(base::as.data.frame(CannabisWowData), 
                    path = paste0("data/processed/", 
                              base::noquote(lubridate::today()),
                                            "-CannabisWowData.csv"))

readr::write_rds(x = CannabisWowData, 
                 path = paste0("data/processed/", 
                              base::noquote(lubridate::today()),
                                            "-CannabisWowData.rds"))

fs::dir_tree("data/processed/", recurse = FALSE)
```


