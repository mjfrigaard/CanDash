---
title: "Part 2 - Visualize Cannabis Data"
author: "Martin Frigaard"
date: "current version: `r Sys.Date()`"
output: github_document
---


```{r setup, include=FALSE}
require(knitr)
require(rmdformats)
require(tidyverse)
require(plotly)
require(janitor)
require(skimr)
require(mosaic)
require(inspectdf)
require(visdat)
require(DT)
require(hrbrthemes)
# base options ----
base::options(
  tibble.print_max = 25,
  tibble.width = 78,
  scipen = 100000000,
  max.print = 999999,
  str = strOptions(
      strict.width = "wrap", 
      vec.len = 3, 
      drop.deparse.attr = TRUE)
)
# knitr chunk options ----
knitr::opts_chunk$set(
  echo = TRUE, # show/hide all code
  # results = "hide", # hide results
  tidy = FALSE, # cleaner code printing
  comment = "#> ", # better console printing
  eval = TRUE, # turn this to FALSE stop code chunks from running
  fig.width = 10, # figure width
  fig.height = 7, # figure height
  warning = FALSE, # show warnings
  message = FALSE,
  size = "small", # size of the text
  fig.path = "figs/"  # location of files
)
# knitr knit settings ----
knitr::opts_knit$set(
  width = 78
)
# set theme
ggplot2::theme_set(hrbrthemes::theme_ipsum_rc(
  base_size = 11,
  strip_text_size = 12,
  axis_title_size = 14,
  plot_title_size = 21,
  subtitle_size = 18
))
```

## Load the packages

These are the packages we will use to visualize the cannabis data. 

```{r package, message=FALSE, warning=FALSE}
library(readr)
library(tidyverse)
library(lubridate)
library(ggthemes)
library(cluster)
library(factoextra)
library(textshape)
library(knitr)
library(rmdformats)
library(plotly)
require(janitor)
require(skimr)
library(mosaic)
library(inspectdf)
library(visdat)
library(DT)
library(hrbrthemes)
```

## Import data 

This data came from a UK e-commerce dataset from the [UCI Machine Learning Laboratory](https://archive.ics.uci.edu/ml/datasets/online+retail) and the [kushy cannabis data set](https://github.com/kushyapp/cannabis-dataset). 

```{r import-CannabisWowData, message=FALSE, warning=FALSE}
# fs::dir_tree("data/processed/")
CannabisWowData <- read_csv("data/processed/2020-03-17-CannabisWowData.csv")
```

```{r check-str}
CannabisWowData %>% utils::str() 
```

This `data.frame` is a combination of some sales data with some product and brand data. 

```{r visualize-brand_category}
CannabisWowData %>% 
  dplyr::count(brand_category, sort = TRUE) %>% 
  dplyr::mutate(brand_category = reorder(brand_category, n)) %>%
  ggplot2::ggplot(aes(x = brand_category, y = n)) +
    ggplot2::geom_col(aes(fill = brand_category), 
                      show.legend = FALSE) +
    ggplot2::labs(x = "Brand Category",
                  y = "Count",
                  title = "Most Common Cannabis Brand Categories") +
    ggplot2::coord_flip()
```

This tells me there are 17 different categories for brands, and `Concentrates` are the most common brand category. I can also see `Flower` and `Edibles` are numbers two and three. 

```{r visualize-product_category}
CannabisWowData %>% 
  dplyr::count(product_category, sort = TRUE) %>% 
  dplyr::mutate(product_category = reorder(product_category, n)) %>%
  ggplot2::ggplot(aes(x = product_category, y = n)) +
    ggplot2::geom_col(aes(fill = product_category), 
                      show.legend = FALSE) +
    ggplot2::labs(x = "Product Category",
                  y = "Count",
                  title = "Most Common Cannabis Product Categories") +
    ggplot2::coord_flip()
```

## Creating week over week data 

The code below creates a data.frame that is 'week-over-week', which is not an uncommon way of reporting sales data. 

```{r WeekOverWeek}
WeekOverWeek <- CannabisWowData %>%
    # get the week_year by quantity
  select(week_year, quantity) %>%
    # group these data
  group_by(week_year) %>%
    # summarize the data by weekly quantity
  summarize(week_qty = sum(quantity)) %>%
    # This introduces the lag function, 
    # Compute a lagged version of a time series, shifting the time base 
    # back by a given number of observations.
  mutate(prev_week = lag(week_qty, 1)) %>%
    # now we get the ratio of the difference between the weekly quantity and 
    # the previous week, and we divide that by the previous week.
  mutate(wow_quantity = (week_qty - prev_week) / prev_week) %>%
    # now we calculate the month, using week_year, abbreviations, and labels
  mutate(month = month(week_year, abbr = TRUE, label = TRUE)) %>%
    # and we group this final data set by the week_year variable
  group_by(week_year)
# check this data set
WeekOverWeek %>% utils::str()
```

Here we see there is a data.frame with 52 rows (one for each week).

## Plot annual sales (by week)

These are the annual sales (line plots) by week, faceted by month. 

```{r adjust-theme}
# set theme
ggplot2::theme_set(hrbrthemes::theme_ipsum_rc(
  base_size = 9,
  strip_text_size = 10,
  axis_title_size = 9,
  plot_title_size = 13,
  subtitle_size = 11
))
```


```{r ggWoWAnnualSales}
  # these are the labels
labs_wow_annual_sales <- ggplot2::labs(
  y = 'Sales', 
  x = 'Week', 
  title = 'Week Over Week Annual Sales',
  subtitle = "Simulated Cannabis Sales Data",
  caption = "graphic and analysis by PDG") 

ggWoWAnnualSales <- WeekOverWeek %>% 
  # this will put week_year on the x
    ggplot2::ggplot(aes(x = week_year, 
                        # and the week over week quantity on the y
                        y = wow_quantity)) +
  # add the line plot
    ggplot2::geom_line() +
  # and the point
    ggplot2::geom_point() +
  # the axis title here will inherit the size and color
    ggplot2::theme(axis.title = element_text(face = c("bold"))) +
  # this will remove the legend
    ggplot2::theme(legend.title = element_blank()) +
  # this adds the percent on the y axis
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1),) +
  # here we facet by the month
    ggplot2::facet_wrap(. ~ month, 
                        # 
                        scales = "free") + 
    ggplot2::theme(axis.text.x = 
                     element_text(angle = 45, 
                                  hjust = 0.5, 
                                  vjust = 0.5)) +
  labs_wow_annual_sales
ggWoWAnnualSales 
```


This shows some missing data in December, and a lot of variance in the sales from month to month. We can check the missing data for December using the graph below

```{r}
WeekOverWeek %>% 
  dplyr::filter(month == "Dec") %>% 
  # this will put week_year on the x
    ggplot2::ggplot(aes(x = week_year, 
                        # and the week over week quantity on the y
                        y = wow_quantity)) +
  # add the line plot
    ggplot2::geom_line() +
  # and the point
    ggplot2::geom_point() +
  # the axis title here will inherit the size and color
    ggplot2::theme(axis.title = element_text(face = c("bold"))) +
  # this will remove the legend
    ggplot2::theme(legend.title = element_blank()) +
  # this adds the percent on the y axis
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1))
```

Now we're wondering what the quantity sold per week is, and we can get this with `week_year` and `week_qty`.

```{r ggWowQuantity}
labs_quantity_per_week <- ggplot2::labs(
         x = "Week", 
         y = "Quantity Sold",
         title = "Quantity Per Week") 

ggWowQuantity <- WeekOverWeek %>%
  # drop missing
    tidyr::drop_na() %>%
  # plot week_year on the x
    ggplot2::ggplot(data = ., 
           aes(x = week_year, 
               # and week quantity on the y
               y = week_qty)) + 
  # add the line plot
    ggplot2::geom_line() +
  # add the smooth (predictor)
    ggplot2::geom_smooth() +
  # add points
    ggplot2::geom_point() +
    labs_quantity_per_week
ggWowQuantity
```

These were used in the previous graph:

```r
    stat_summary(fun.y = mean,
                 geom = "bar") +
    stat_summary(fun.data = mean_cl_boot,
                 geom = "errorbar",
                 width = 0.3) +
```

But I opted for the line + points. 

## Create Monthly Sales by Location 

Next we create the monthly sales data frame, with the `unit_price`, `quantity`, `location`, and `floor_month`.

```{r MonthlyLocationSales}
MonthlyLocationSales <- CannabisWowData %>% 
    # get the floor_month. location, quantity, and unit_price
    dplyr::select(floor_month, 
                  location, 
                  quantity,  
                  unit_price) %>%
    # we can create the "sales"
    dplyr::mutate(sales = quantity*unit_price) %>%
    # now we group by the floor_month and location
    dplyr::group_by(floor_month, location) %>%
    # and summarize this by the monthly_sales and median sales
    dplyr::summarize(total_monthly_sales = sum(sales, na.rm = TRUE), 
                     median_monthly_sales = median(sales, na.rm = TRUE)) %>%
    # and group it by the floor_month and location
    dplyr::group_by(floor_month, location) %>% 
    # remove the SP location
    dplyr::filter(location != "SP")
# check new data 
MonthlyLocationSales %>% dplyr::glimpse(78)
```

This gives us a grouped `data.frame` with 138 rows. 

## Plot Monthly Sales by Location

This plot will graph the monthly sales of cannabis products by their location (abbreviated). 

```{r ggTop100MonthlyLocationSales}
# labels
labs_monthly_location_sales <- ggplot2::labs(y = 'Total Monthly Sales',
                  x = 'Month',
                  title = 'Total Monthly Sales By Location')

# plot
ggTop100MonthlyLocationSales <- MonthlyLocationSales %>%
    # sort these by total_monthly_sales
    dplyr::arrange(desc(total_monthly_sales)) %>% 
    # plot this as floor_month vs. monthly sales
    ggplot2::ggplot(data = ., 
                    # month
                    aes(x = floor_month, 
                        # total monthly sales here
                        y = total_monthly_sales)) +
    # add a line
    ggplot2::geom_line() +
    # and a point
    ggplot2::geom_point() +
    # and a theme
    ggplot2::theme(axis.title = 
                     element_text()) +   
    # with legend title
    ggplot2::theme(legend.title = 
                     element_blank()) +
    # and the scales for dollar formats
    ggplot2::scale_y_continuous(labels = 
                                  scales::dollar_format(accuracy = 1)) +
    # facet by the location
    ggplot2::facet_wrap(. ~ location, 
                        scales = "free", 
                        ncol = 4) + 
    # adjust the x axis text
    ggplot2::theme(axis.text.x = 
                     element_text(angle = 45, 
                                  hjust = 0.5, 
                                  vjust = 0.5)) +
    # 
    labs_monthly_location_sales
ggTop100MonthlyLocationSales 
```

Faceting by location and having months on the x axis is helpful for spotting trends, but graphs like this can help us spot gaps in total sales by location (i.e. California vs. Manitoba).

## Median Order Sales by Location 

This is the median sales by `floor_month`, sorted by the `median_sales`. 

```{r ggMedianOrderValue, message=FALSE, warning=FALSE}
# labels
labs_median_order_value <- ggplot2::labs(
                  y = 'Median Monthly Sales', 
                  x = 'Floor Month',
                  title = 'Median Monthly Sales by Location')
# plot
ggMedianOrderValue <- MonthlyLocationSales %>%
    # sort these by median_sales
    dplyr::arrange(desc(median_monthly_sales)) %>% 
    # plot
    ggplot2::ggplot(data = ., 
                    # put months on the x 
           mapping = aes(x = floor_month, 
                         # median monthly sales
                         y = median_monthly_sales)) +
    # add the line
    ggplot2::geom_line() +
    # add the point
    ggplot2::geom_point() +
    # add the y format
    ggplot2::scale_y_continuous(labels = 
                                    scales::dollar_format(accuracy = 1)) +
  
    # facet this by the location and set scales to free
    ggplot2::facet_wrap(. ~ location, 
                        scales = "free") + 
  
      # adjust the x axis text
    ggplot2::theme(axis.text.x = 
                     element_text(angle = 45, 
                                  hjust = 0.5, 
                                  vjust = 0.5)) +
  # add the labels
  labs_median_order_value

ggMedianOrderValue
```

## Create Customer Sales data

These data are the sales by customer id. We create this data frame by grouping on `customer_id`, then create a `sales` variable by multiplying the quantity by the unit price (`quantity * unit_price`).

We also create three variables that aggregate the sales (`sum` and `median`).

```{r CustomerSales}
CustomerSales <- CannabisWowData %>%
    # select the customer_id, quantity, and unit_price
    dplyr::select(id, quantity, unit_price) %>%
    # group it by the customer id
    dplyr::group_by(id) %>%
    # create sales (which is the product of quantity and price)
    dplyr::mutate(sales = (quantity * unit_price)) %>%
    # summarize
    dplyr::summarize(
            sales_sum = sum(sales),
            sales_median = median(sales),
            quantity_sum = sum(quantity),
            quantiy_median = median(quantity)) %>%
    # we group this again by customer id
    dplyr::group_by(id)
CustomerSales %>% dplyr::glimpse(78)
```

## Customer location data

We now join the `CustomerSales` data to a data frame with the distinct customer ids and countries (`CustomersLocation`).

```{r join-CustomersCountry}
CustomersLocation <- CannabisWowData %>%
    dplyr::distinct(id, location) %>%
    dplyr::group_by(id)
# join this to the CustomersLocation
CustomersSalesLocation <- CustomerSales %>%
    dplyr::inner_join(CustomersLocation, 
               by = "id")
# check
CustomersSalesLocation %>% dplyr::glimpse(78)
```

### Create cluster (modeling) data frame

Ok, now we are going to convert the grouped data frame, drop the missing rows, and remove any data where sales were less than zero.

```{r CustomerSalesClust}
# convert to data frame
CustomerSalesClust <- base::data.frame(CustomerSales)

CustomerSalesClust <- CustomerSalesClust %>%  
    # drop na 
                        tidyr::drop_na() %>%
    # remove sales less than 0
                        dplyr::filter(sales_sum > 0)
skimr::skim(CustomerSalesClust)
```

## k-means clustering

Finally, we run a k-means clustering algorithm on the clustered sales data. *What does a k-means clustering do?* Well, here is a great definition on [Medium](https://towardsdatascience.com/understanding-k-means-clustering-in-machine-learning-6a6e67336aa1), 

> the objective of K-means is simple: group similar data points together and discover underlying patterns. To achieve this objective, K-means looks for a fixed number (k) of clusters in a dataset.

The k-means algorithm is an **unsupervised machine learning algorithm.** The steps to perform this are: 

1. Use the `textshape::column_to_rownames()` function on the clustered data frame. This function 

> "*Takes an existing column and uses it as rownames instead. This is useful when turning a data.frame into a matrix. Inspired by the tibble package's `column_to_row` which is now deprecated if done on a `tibble` object. By coercing to a `data.frame` this problem is avoided.*"

We're going to use the non-descript name, `CustomerSalesClust2`. to show what this function is actually doing. The `utils::str()` function gives us some information on what kind of object we've created here.

```{r column_to_rownames}
CustomerSalesClust2 <- textshape::column_to_rownames(CustomerSalesClust) 
utils::str(CustomerSalesClust)
utils::str(CustomerSalesClust2)
```

The `CustomerSalesClust2` took the existing data frame (`CustomerSalesClust`) and removed a column (`customer_id`) and assigned them a rowname `base::rownames()`.

```{r rownames}
base::rownames(CustomerSalesClust2) %>% head()
```


2. The 2nd step is to Scale the new `CustomerSalesClust` with `base::scale()`, which now has been transformed via the `textshape::column_to_rownames()` function. The `scale()` function who's, "*default method centers and/or scales the columns of a numeric matrix.*"

```{r scale}
CustomerSalesClust3 <- base::scale(CustomerSalesClust2)
str(CustomerSalesClust3)
```

Use the `kmeans()` function with the specifications below:

`centers` = A matrix of cluster centres.
`nstart` = 

```{r k2}
k2 <- kmeans(CustomerSalesClust, 
             # the number of cluster centries
             centers = 2 , 
             ## random starts do help here with too many clusters
             ## (and are often recommended anyway!):
             nstart = 25)
k2
```


```{r five-cluster}
fviz_cluster(k2, data = CustomerSalesClust3)
```

```{r CustomerSalesCluser}
CustomerSalesCluser <- base::data.frame(CustomerSalesClust, k2$cluster)
CustomerSalesCluser %>% dplyr::glimpse(78)
```




